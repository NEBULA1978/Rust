Para compilar archivo:
rustc main.rs

Para ejecutar archivo complidado creado:
./main


Resultado por consola:

‚ùØ ./main

¬°Hola, mundo!
El valor de x es: 5
Ahora, el valor de x es: 10
El n√∫mero es impar
Iteraci√≥n 0
Iteraci√≥n 1
Iteraci√≥n 2
Iteraci√≥n 3
Iteraci√≥n 4
Bucle while: 0
Bucle while: 1
Bucle while: 2

////////////////////////
////////////////////////

Preguntas pagina:
https://learn.microsoft.com/en-us/training/modules/rust-introduction/3-rust-features

1. What's a compelling advantage of working with Rust? 
Ôøº
Rust is type-safe, memory-safe, and data race-free.
Correct! Data types in Rust are verified at compile time, pointers (references) always refer to valid memory, and thread-safety is guaranteed.

Ôøº
Rust is optimized for bare-metal development like operating systems.
Ôøº
Rust has a robust garbage collector and helps to manage memory efficiently.
2. How is Rust code executed? 
Ôøº
Scripts are interpreted by Rust.
Ôøº
Rust code must be included in a C/C++ source file.
Ôøº
Through compilation followed by direct execution.
Correct. Rust code is compiled into an executable file, and then the executable is run.

3. What's an example of something you can't do with Cargo? 
Ôøº
Build an existing Rust project.
Ôøº
Update the installed Rust compiler version.
Correct. You can't update the Rust compiler version by using Cargo. Use the rustup command to update the Rust compiler version.

//////////////////

 ¬øCu√°l es una ventaja convincente de trabajar con Rust? 

Rust es seguro para tipos, memoria y datos sin carreras.
¬°Correcto! Los tipos de datos en Rust se verifican en el momento de la compilaci√≥n, los punteros (referencias) siempre hacen referencia a una memoria v√°lida y la seguridad de los subprocesos est√° garantizada.


Rust est√° optimizado para el desarrollo b√°sico, como los sistemas operativos.

Rust tiene un recolector de basura robusto y ayuda a administrar la memoria de manera eficiente.
2. ¬øC√≥mo se ejecuta el c√≥digo Rust? 

Los guiones son interpretados por Rust.

El c√≥digo Rust debe incluirse en un archivo fuente C/C++.

Mediante compilaci√≥n seguida de ejecuci√≥n directa.
Correcto. El c√≥digo Rust se compila en un archivo ejecutable y luego se ejecuta el ejecutable.

3. ¬øCu√°l es un ejemplo de algo que no puedes hacer con Cargo? 

Construya un proyecto Rust existente.

Actualice la versi√≥n instalada del compilador Rust.
Correcto. No puedes actualizar la versi√≥n del compilador Rust usando Cargo. Utilice el comando rustup para actualizar la versi√≥n del compilador de Rust.

//////////////////////
//////////////////////

Comprueba tus conocimientos
Responda las siguientes preguntas para ver lo que ha aprendido. Elija una respuesta para cada pregunta y luego seleccione Compruebe sus respuestas.

Ôøº
1. ¬øQu√© herramienta de juego de Rust puedes usar para encontrar errores en tu c√≥digo? 
Ôøº
oxidado
Ôøº
clippy
Correct. You can use the Clippy collection of lint tests to find mistakes in your code and see suggestions for how to improve your code.

Ôøº
Depurar
2. ¬øCu√°ndo no est√° disponible una conexi√≥n de red en el patio de juegos de Rust? 
Ôøº
Al editar c√≥digo.
Ôøº
Al ejecutar un programa.
Ôøº
Al compilar c√≥digo o ejecutar un programa.
Correct. When you compile code or run a program in the playground, a network connection isn't available.

////////////////////////////
////////////////////////////
Comprobaci√≥n de conocimientos
Responda a las preguntas siguientes para ver lo que ha aprendido. Elija una respuesta para cada pregunta y, despu√©s, seleccione Comprobar respuestas.

Ôøº
1. ¬øCu√°l es el comando recomendado que se debe usar para instalar Rust? 
Ôøº
rinstall
Ôøº
rustup
Correcto. El comando rustup es un instalador de cadena de herramientas para Rust. Puede actualizar el entorno a la versi√≥n estable m√°s reciente de Rust si ejecuta el comando rustup update.

Ôøº
rupdate
2. ¬øCon qu√© frecuencia se actualizan las bibliotecas de Rust? 
Ôøº
Cada seis meses
Ôøº
Cada tres meses
Ôøº
Cada seis semanas
Correcto. Rust tiene un proceso de versiones r√°pidas de seis semanas. Hay muchas compilaciones de Rust disponibles en cualquier momento.

///////////////////////
///////////////////////

Compilaci√≥n y ejecuci√≥n del programa con Cargo
Para ejecutar el programa reutilizable, pasaremos al nuevo directorio hello-cargo y, a continuaci√≥n, usaremos el comando cargo run.

Ejecute los siguientes comandos en el terminal:

Consola
Ôøº
Copiar
cd hello-cargo
cargo run

Deber√≠a aparecer la salida siguiente en el terminal:

Output
Ôøº
Copiar
  Compiling hello-cargo v0.1.0 (/tmp/.OFUp/hello-cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 1.59s
      Running `target/debug/hello-cargo`

Hello, world!
Cargo ha compilado y ejecutado el archivo ejecutable.

Enhorabuena, ha escrito el primer programa de Rust y ha aprendido a inicializar el primer proyecto de Rust con Cargo.

///////////////////////////////////////
///////////////////////////////////////

Comprobaci√≥n de conocimientos
Responda a las preguntas siguientes para ver lo que ha aprendido. Elija una respuesta para cada pregunta y, despu√©s, seleccione Comprobar las respuestas.


1. ¬øCu√°ntas funciones principales puede haber en un programa de Rust? 

Un programa de Rust puede tener tantas funciones main como sea necesario.

Cualquier funci√≥n de Rust puede tener una subfunci√≥n denominada main.

Cada programa de Rust solo debe tener una funci√≥n llamada main.
Correcto. Un programa de Rust solo puede tener una funci√≥n main.

2. ¬øQu√© palabra clave de Rust se usa para declarar una funci√≥n nueva? 

function

fn
Correcto. La palabra clave fn se usa para declarar cualquier funci√≥n, incluida main.


func
3. ¬øCu√°l es la salida de esta llamada a la macro println!?
println!("{} is a number. {} is a word.", 1, "Two"); 

1 is a number. Two is a word.
Correcto. La macro println! reemplaza cada instancia de llaves {} por el siguiente valor de argumento.


{} is a number. {} is a word.

{1} is a number. {"Two"} is a word.

///////////////////////////////////////////
///////////////////////////////////////////

VARIABLES

// Declare a variable
let a_number;
    
// Declare a second variable and bind the value
let a_word = "Ten";
    
// Bind a value to the first variable
a_number = 10;

println!("The number is {}.", a_number);
println!("The word is {}.", a_word);
Nuestro ejemplo imprime la siguiente salida:

Output
Ôøº
Copiar
The number is 10.
The word is Ten.

///////////////////////////////////////
///////////////////////////////////////

Para mutar un valor, debemos usar en primer lugar la palabra clave mut para convertir en mutable el enlace de una variable.

// The `mut` keyword lets the variable be changed
let mut a_number = 10; 
println!("The number is {}.", a_number);

// Change the value of an immutable variable
a_number = 15;
println!("Now the number is {}.", a_number);

Este ejemplo imprime la salida siguiente:
The number is 10.
Now the number is 15.

////////////////////////////////////
////////////////////////////////////

Propiedad reemplazada de variables
Puede declarar una variable nueva que use el nombre de una existente. La declaraci√≥n nueva crea un enlace. En Rust, esta operaci√≥n se denomina "propiedad reemplazada" porque la nueva variable prevalece sobre la anterior. La antigua variable sigue existiendo, pero ya no se puede hacer referencia a ella en este √°mbito.

En el c√≥digo siguiente se muestra c√≥mo usar la propiedad reemplazada. Declaramos una variable denominada shadow_num. No definimos la variable como mutable porque cada operaci√≥n let crea una variable denominada shadow_num mientras se reemplaza la propiedad del enlace de la variable anterior.

// Declare first variable binding with name "shadow_num"
let shadow_num = 5;

// Declare second variable binding, shadows existing variable "shadow_num" 
let shadow_num = shadow_num + 5; 

// Declare third variable binding, shadows second binding of variable "shadow_num"
let shadow_num = shadow_num * 2; 

println!("The number is {}.", shadow_num);

Comprobaci√≥n de conocimientos
Responda a las preguntas siguientes para ver lo que ha aprendido. Elija una respuesta para cada pregunta y, despu√©s, seleccione Comprobar las respuestas.

Ôøº
1. ¬øQu√© instrucci√≥n de Rust declara una variable y enlaza un valor? 
Ôøº
let continents = 7;
Correcto. La palabra clave let declara la variable y el signo igual = enlaza el valor.

Ôøº
continents = 7;
Ôøº
let continents;
2. ¬øQu√© palabra clave de Rust se usa para hacer que el valor de una variable sea modificable? 
Ôøº
mutable
Ôøº
immutable
Ôøº
mut
Correcto. La palabra clave mut se usa para declarar el valor de una variable para que sea modificable.

/////////////////////////////////////////////
/////////////////////////////////////////////

Exploraci√≥n de tipos de datos para n√∫meros, texto y valores true/false
200 XP
7 minutos
Rust es un lenguaje con establecimiento de tipos en modo est√°tico. El compilador debe conocer el tipo de datos exacto de todas las variables del c√≥digo para que el programa se compile y ejecute. Normalmente, el compilador puede inferir el tipo de datos de una variable en funci√≥n del valor enlazado. No siempre es necesario indicar de forma expl√≠cita el tipo en el c√≥digo. Cuando son posibles muchos tipos, debe informar al compilador del tipo espec√≠fico mediante anotaciones de tipo.

En el ejemplo siguiente, se le indica al compilador que cree la variable number como un entero de 32 bits. Especificamos el tipo de datos u32 despu√©s del nombre de la variable. Observe que despu√©s del nombre de la variable se usa el car√°cter de dos puntos :.

Rust

Copiar
let number: u32 = 14;
println!("The number is {}.", number);
Si ponemos el valor de la variable entre comillas dobles, el compilador interpreta el valor como texto en lugar de como un n√∫mero. El tipo de datos deducido del valor no coincide con el tipo de datos u32 especificado para la variable, por lo que el compilador emite un error:

Rust

Copiar
let number: u32 = "14";
Error del compilador:

Output

Copiar
   Compiling playground v0.0.1 (/playground)
error[E0308]: mismatched types
 --> src/main.rs:2:23
  |
2 |     let number: u32 = "14";
  |                 ---   ^^^^ expected `u32`, found `&str`
  |                 |
  |                 expected due to this

error: aborting due to previous error
Se puede interactuar con el c√≥digo anterior en esta √°rea de juegos de Rust.

Tipos de datos integrados
Rust incluye algunos tipos de datos primitivos integrados para expresar n√∫meros, texto y veracidad. Algunos de estos tipos se conocen como escalares, porque representan un solo valor:

N√∫meros enteros
N√∫meros de punto flotante
Valores booleanos
Characters
Rust tambi√©n ofrece tipos de datos m√°s complejos para trabajar con series de datos, como valores de cadena y de tupla.

N√∫meros: valores enteros y de punto flotante
Los enteros en Rust se identifican por el tama√±o en bits y la propiedad signed. Un entero con signo puede ser un n√∫mero positivo o negativo. Un entero sin signo solo puede ser un n√∫mero positivo.

Length	Firmado	Sin signo	 	 
8 bits	i8	u8	 	 
16 bits	i16	u16	 	 
32 bits	i32	u32	 	 
64 bits	i64	u64	 	 
128 bits	i128	u128	 	 
dependiente de la arquitectura	isize	usize	 	 
Los tipos isize y usize dependen del tipo de equipo en el que se ejecuta el programa. El tipo de 64 bits se usa en una arquitectura de 64 bits y el tipo de 32 bits, en una arquitectura de 32 bits. Si no especifica el tipo para un entero, y el sistema no puede deducir el tipo, asigna el tipo i32 (un entero de 32 bits con signo) de forma predeterminada.

Rust tiene dos tipos de datos de punto flotante para los valores decimales: f32 (32 bits) y f64 (64 bits). El tipo de punto flotante predeterminado es f64. En las CPU modernas, el tipo f64 tiene aproximadamente la misma velocidad que el tipo f32, pero cuenta con una mayor precisi√≥n.

Rust

Copiar
let number_64 = 4.0;      // compiler infers the value to use the default type f64
let number_32: f32 = 5.0; // type f32 specified via annotation
Todos los tipos de n√∫meros primitivos en Rust admiten operaciones matem√°ticas como suma, resta, multiplicaci√≥n y divisi√≥n.

Rust

Copiar
// Addition, Subtraction, and Multiplication
println!("1 + 2 = {} and 8 - 5 = {} and 15 * 3 = {}", 1u32 + 2, 8i32 - 5, 15 * 3);

// Integer and Floating point division
println!("9 / 2 = {} but 9.0 / 2.0 = {}", 9u32 / 2, 9.0 / 2.0);
 Nota

Cuando llamamos a la macro println, agregamos el sufijo de tipo de datos a cada n√∫mero literal para informar a Rust sobre el tipo de datos. La sintaxis 1u32 indica al compilador que el valor es el n√∫mero 1 y que interprete el valor como un entero de 32 bits sin signo.

Si no se proporcionan anotaciones de tipo, Rust intenta deducir el tipo a partir del contexto. Cuando el contexto es ambiguo, asigna el tipo i32 (un entero de 32 bits con signo) de forma predeterminada.

Se puede intentar ejecutar este ejemplo en el √°rea de juegos de Rust.

Valores booleanos: true o false
El tipo booleano en Rust se usa para almacenar la veracidad. El tipo bool tiene dos valores posibles: true o false. Los valores booleanos se usan de forma generalizada en expresiones condicionales. Si una instrucci√≥n bool o un valor es true, realice esta acci√≥n; de lo contrario (la instrucci√≥n o el valor es false), realice una acci√≥n distinta. Una comprobaci√≥n de comparaci√≥n suele devolver un valor booleano.

En el ejemplo siguiente, usamos el operador mayor que > para probar dos valores. El operador devuelve un valor booleano que muestra el resultado de la prueba.

Rust

Copiar
// Declare variable to store result of "greater than" test, Is 1 > 4? -- false
let is_bigger = 1 > 4;
println!("Is 1 > 4? {}", is_bigger);  
Texto: caracteres y cadenas
Rust admite valores de texto con dos tipos de cadena b√°sicos y un tipo de car√°cter. Un car√°cter es un elemento √∫nico, mientras que una cadena es una serie de caracteres. Todos los tipos de texto son representaciones UTF-8 v√°lidas.

Characters
El tipo char es el m√°s primitivo de los tipos de texto. El valor se especifica poniendo el elemento entre comillas simples:

Rust

Copiar
let uppercase_s = 'S';
let lowercase_f = 'f';
let smiley_face = 'üòÉ';
 Nota

Algunos lenguajes tratan sus tipos char como enteros de 8 bits sin signo, que es el equivalente del tipo u8 de Rust. El tipo char de Rust contiene puntos de c√≥digo Unicode, pero no usa la codificaci√≥n UTF-8. char en Rust es un entero de 21 bits que se ha agregado para ampliar a 32 bits. char contiene directamente el valor de punto de c√≥digo sin formato. Puede obtener m√°s informaci√≥n sobre el tipochar de Rust en la documentaci√≥n de Rust.

Cadenas
El tipo str, tambi√©n conocido como segmento de cadena, es una vista de los datos de la cadena. La mayor√≠a de las veces, se hace referencia a estos tipos usando la sintaxis del estilo de referencia que precede al tipo con el s√≠mbolo de y comercial &str. Trataremos las referencias en los siguientes m√≥dulos. Por ahora, puede imaginarse &str como un puntero a datos de cadena inmutables. Los literales de cadena son todos de tipo &str.

Aunque los literales de cadena son convenientes para usarlos en ejemplos de introducci√≥n de Rust, no son adecuados para todas las situaciones en las que podr√≠amos querer usar texto. No todas las cadenas pueden conocerse en tiempo de compilaci√≥n. Un ejemplo se da cuando un usuario interact√∫a con un programa en tiempo de ejecuci√≥n y env√≠a texto mediante un terminal.

En estos escenarios, Rust tiene un segundo tipo de cadena denominado String. Este tipo se asigna en el mont√≥n. Cuando se usa el tipo String, no es necesario conocer la longitud de la cadena (n√∫mero de caracteres) antes de compilar el c√≥digo.

 Nota

Si est√° familiarizado con un lenguaje de recolecci√≥n de elementos no utilizados, es posible que se pregunte por qu√© Rust tiene dos tipos de cadena. 1 Las cadenas son tipos de datos extremadamente complejos. La mayor√≠a de los lenguajes usan sus recolectores de elementos no utilizados para atenuar esta complejidad. Rust, como lenguaje de un sistema, expone parte de la complejidad inherente de las cadenas. La complejidad adicional conlleva una cantidad de control muy espec√≠fica sobre c√≥mo se usa la memoria en el programa.

1 _En realidad, Rust tiene m√°s de dos tipos de cadena. En este m√≥dulo, solo se describen los tipos String y &str. Puede obtener m√°s informaci√≥n sobre los tipos de cadena que se ofrecen en la documentaci√≥n de Rust.

No va a obtener una idea completa de la diferencia entre String y &str hasta que conozca la propiedad y el sistema de pr√©stamos de Rust. Hasta entonces, puede pensar en los datos de tipo String como datos de texto que pueden cambiar a medida que se ejecuta el programa. Las referencias &str son vistas inmutables en los datos de texto que no cambian a medida que se ejecuta el programa.

Ejemplo de texto
En el ejemplo siguiente se muestra c√≥mo usar los tipos de datos char y &str en Rust.

Se declaran dos variables de caracteres con la sintaxis de anotaci√≥n : char. Los valores se especifican usando comillas simples.
Se declara una tercera variable de caracteres y se enlaza a una sola imagen. Para esta variable, se permite que el compilador deduzca el tipo de datos.
Se declaran dos variables de cadena y se enlazan a sus valores respectivos. Las cadenas se ponen entre comillas dobles.
Una de las variables de cadena se declara con la sintaxis de anotaci√≥n : &str para especificar el tipo de datos. El tipo de datos de la otra variable se deja sin especificar. El compilador deducir√° el tipo de datos de esta variable en funci√≥n del contexto.
Observe que la variable string_1 incluye un espacio vac√≠o al final de la serie de caracteres.

Rust

Copiar
// Specify the data type "char"
let character_1: char = 'S';
let character_2: char = 'f';
   
// Compiler interprets a single item in quotations as the "char" data type
let smiley_face = 'üòÉ';

// Compiler interprets a series of items in quotations as a "str" data type and creates a "&str" reference
let string_1 = "miley ";

// Specify the data type "str" with the reference syntax "&str"
let string_2: &str = "ace";

println!("{} is a {}{}{}{}.", smiley_face, character_1, string_1, character_2, string_2);
Esta es la salida de nuestro ejemplo:

Output

Copiar
üòÉ is a Smiley face.
¬øQu√© ocurre si no se especifica el s√≠mbolo de y comercial & antes de str en este ejemplo? Para averiguarlo, intente ejecutar este ejemplo en el √Årea de juegos de Rust.

Comprobaci√≥n de conocimientos
Responda a las preguntas siguientes para ver lo que ha aprendido. Elija una respuesta para cada pregunta y, despu√©s, seleccione Comprobar las respuestas.


1. ¬øQu√© afirmaci√≥n describe c√≥mo se definen los valores num√©ricos enteros en Rust? 

En Rust, los enteros se identifican principalmente por su tama√±o de bits, por ejemplo 8 bits, 16 bits, y as√≠ sucesivamente.

En Rust, los enteros se identifican por su tama√±o en bits y la propiedad con signo.

En Rust, un entero positivo o negativo se puede definir como un valor sin signo (u) o con signo (i).
2. ¬øQu√© afirmaci√≥n describe correctamente c√≥mo se admiten en Rust los valores de caracteres de texto? 

Rust tiene un tipo de datos que se puede usar tanto para caracteres √∫nicos como para cadenas de texto de varios caracteres.

Un car√°cter (char) solo puede ser una sola letra alfa, como "A" o "z". Una cadena puede ser una serie de caracteres cualquiera: letras, n√∫meros, im√°genes, entre otros.

En Rust, todos los tipos de texto son representaciones UTF-8 v√°lidas.


/////////////////////////////////

let uppercase_s = 'S';
let lowercase_f = 'f';
let smiley_face = 'üòÉ';

/////////////////////////////////

Comprobaci√≥n de conocimientos
Responda a las preguntas siguientes para ver lo que ha aprendido. Elija una respuesta para cada pregunta y, despu√©s, seleccione Comprobar las respuestas.

Ôøº
1. ¬øQu√© afirmaci√≥n describe c√≥mo se definen los valores num√©ricos enteros en Rust? 
Ôøº
En Rust, los enteros se identifican principalmente por su tama√±o de bits, por ejemplo 8 bits, 16 bits, y as√≠ sucesivamente.
Ôøº
En Rust, los enteros se identifican por su tama√±o en bits y la propiedad con signo.
Correcto. Un entero se identifica mediante una combinaci√≥n de su tama√±o de bits y si tiene signo (i) o no tiene signo (u).

Ôøº
En Rust, un entero positivo o negativo se puede definir como un valor sin signo (u) o con signo (i).
2. ¬øQu√© afirmaci√≥n describe correctamente c√≥mo se admiten en Rust los valores de caracteres de texto? 
Ôøº
Rust tiene un tipo de datos que se puede usar tanto para caracteres √∫nicos como para cadenas de texto de varios caracteres.
Ôøº
Un car√°cter (char) solo puede ser una sola letra alfa, como "A" o "z". Una cadena puede ser una serie de caracteres cualquiera: letras, n√∫meros, im√°genes, entre otros.
Ôøº
En Rust, todos los tipos de texto son representaciones UTF-8 v√°lidas.
Correcto. En Rust, todos los tipos de texto son representaciones UTF-8 v√°lidas.

///////////////////////
///////////////////////



